// This is generated by writeCoreEval; please edit!
/* eslint-disable */

const manifestBundleRef = {bundleID:"b1-039e04dafa79c7d7f705b7512a357f0b28b0dc889cc07c99a61ab66bd4ec76d76ff17c11ba1dd1b3868f503e1fb27c33f763bac042667ef551bf5cf5615be896"};
const getManifestCall = harden([
  "getManifest",
  {
    installKeys: {
      ElysContract: {
        bundleID: "b1-42f1ec1d0fe4c54de4f3e4127fdbe185c74ce2a1b235908bbd57893cbdfe77068e88d6994bd08f44747e89068e5e8a99c4d53cdd39a6d9fa03c8ba396c600cf2",
      },
    },
    options: {
      assetInfo: [
        [
          "uist",
          {
            baseDenom: "uist",
            baseName: "agoric",
            chainName: "agoric",
          },
        ],
        [
          "ubld",
          {
            baseDenom: "ubld",
            baseName: "agoric",
            chainName: "agoric",
          },
        ],
        [
          "uatom",
          {
            baseDenom: "uatom",
            baseName: "cosmoshub",
            chainName: "cosmoshub",
          },
        ],
        [
          "uelys",
          {
            baseDenom: "uelys",
            baseName: "elys",
            chainName: "elys",
          },
        ],
        [
          "ibc/89BB00177EBDF554BF8382094D770DC3EA1C7F5945A48D61C07A867C6ED6709B",
          {
            baseDenom: "ibc/EF3BDB6C8222A465BF8EC6B02EBE350E82DC0AC4FDB75286A92B8433A3B026EC",
            baseName: "elys",
            chainName: "agoric",
          },
        ],
      ],
      chainInfo: {
        agoric: {
          bech32Prefix: "agoric",
          chainId: "agoricdev-25",
          connections: {
            "cosmoshub-4": {
              client_id: "07-tendermint-18",
              counterparty: {
                client_id: "07-tendermint-18",
                connection_id: "connection-224",
              },
              id: "connection-17",
              state: 3,
              transferChannel: {
                channelId: "channel-25",
                counterPartyChannelId: "channel-17",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "elys-1": {
              client_id: "07-tendermint-16",
              counterparty: {
                client_id: "07-tendermint-16",
                connection_id: "connection-10",
              },
              id: "connection-16",
              state: 3,
              transferChannel: {
                channelId: "channel-23",
                counterPartyChannelId: "channel-11",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "stride-1": {
              client_id: "07-tendermint-15",
              counterparty: {
                client_id: "07-tendermint-15",
                connection_id: "connection-44",
              },
              id: "connection-15",
              state: 3,
              transferChannel: {
                channelId: "channel-13",
                counterPartyChannelId: "channel-60",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
          },
          icaEnabled: false,
          icqEnabled: false,
          namespace: "cosmos",
          pfmEnabled: true,
          reference: "agoric-3",
          stakingTokens: [
            {
              denom: "ubld",
            },
          ],
        },
        cosmoshub: {
          bech32Prefix: "cosmos",
          chainId: "provider",
          connections: {
            "agoric-3": {
              client_id: "07-tendermint-18",
              counterparty: {
                client_id: "07-tendermint-18",
                connection_id: "connection-17",
              },
              id: "connection-224",
              state: 3,
              transferChannel: {
                channelId: "channel-17",
                counterPartyChannelId: "channel-25",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "stride-1": {
              client_id: "07-tendermint-317",
              counterparty: {
                client_id: "07-tendermint-70",
                connection_id: "connection-48",
              },
              id: "connection-225",
              state: 3,
              transferChannel: {
                channelId: "channel-389",
                counterPartyChannelId: "channel-62",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
          },
          icaEnabled: true,
          icqEnabled: false,
          namespace: "cosmos",
          pfmEnabled: true,
          reference: "cosmoshub-4",
          stakingTokens: [
            {
              denom: "uatom",
            },
          ],
        },
        elys: {
          bech32Prefix: "elys",
          chainId: "elysicstestnet-1",
          connections: {
            "agoric-3": {
              client_id: "07-tendermint-16",
              counterparty: {
                client_id: "07-tendermint-16",
                connection_id: "connection-16",
              },
              id: "connection-10",
              state: 3,
              transferChannel: {
                channelId: "channel-11",
                counterPartyChannelId: "channel-23",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "stride-1": {
              client_id: "07-tendermint-19",
              counterparty: {
                client_id: "07-tendermint-69",
                connection_id: "connection-46",
              },
              id: "connection-11",
              state: 3,
              transferChannel: {
                channelId: "channel-12",
                counterPartyChannelId: "channel-61",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
          },
          icaEnabled: false,
          icqEnabled: false,
          namespace: "cosmos",
          pfmEnabled: false,
          reference: "elys-1",
          stakingTokens: [
            {
              denom: "uelys",
            },
          ],
        },
        stride: {
          bech32Prefix: "stride",
          chainId: "stride-internal-1",
          connections: {
            "agoric-3": {
              client_id: "07-tendermint-15",
              counterparty: {
                client_id: "07-tendermint-15",
                connection_id: "connection-15",
              },
              id: "connection-44",
              state: 3,
              transferChannel: {
                channelId: "channel-60",
                counterPartyChannelId: "channel-13",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "cosmoshub-4": {
              client_id: "07-tendermint-70",
              counterparty: {
                client_id: "07-tendermint-317",
                connection_id: "connection-225",
              },
              id: "connection-48",
              state: 3,
              transferChannel: {
                channelId: "channel-62",
                counterPartyChannelId: "channel-389",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
            "elys-1": {
              client_id: "07-tendermint-69",
              counterparty: {
                client_id: "07-tendermint-19",
                connection_id: "connection-11",
              },
              id: "connection-46",
              state: 3,
              transferChannel: {
                channelId: "channel-61",
                counterPartyChannelId: "channel-12",
                counterPartyPortId: "transfer",
                ordering: 0,
                portId: "transfer",
                state: 3,
                version: "ics20-1",
              },
            },
          },
          icaEnabled: true,
          icqEnabled: false,
          namespace: "cosmos",
          pfmEnabled: true,
          reference: "stride-1",
          stakingTokens: [
            {
              denom: "ustrd",
            },
          ],
        },
      },
    },
  },
]);
const customManifest = {
  startElys: {
    consume: {
      agoricNames: true,
      board: true,
      chainStorage: true,
      chainTimerService: true,
      cosmosInterchainService: true,
      localchain: true,
      startUpgradable: true,
    },
    installation: {
      consume: {
        ElysContract: true,
      },
    },
    instance: {
      produce: {
        ElysContract: true,
      },
    },
  },
};

// Make a behavior function and "export" it by way of script completion value.
// It is constructed by an anonymous invocation to ensure the absence of a global binding
// for makeCoreProposalBehavior, which may not be necessary but preserves behavior pre-dating
// https://github.com/Agoric/agoric-sdk/pull/8712 .
const behavior = (({
  manifestBundleRef,
  getManifestCall: [manifestGetterName, ...manifestGetterArgs],
  customManifest,
  E,
  log = console.info,
  customRestoreRef,
}) => {
  const { entries, fromEntries } = Object;

  /**
   * Given an object whose properties may be promise-valued, return a promise
   * for an analogous object in which each such value has been replaced with its
   * fulfillment.
   * This is a non-recursive form of endo `deeplyFulfilled`.
   *
   * @template T
   * @param {{[K in keyof T]: (T[K] | Promise<T[K]>)}} obj
   * @returns {Promise<T>}
   */
  const shallowlyFulfilled = async obj => {
    if (!obj) {
      return obj;
    }
    const awaitedEntries = await Promise.all(
      entries(obj).map(async ([key, valueP]) => {
        const value = await valueP;
        return [key, value];
      }),
    );
    return fromEntries(awaitedEntries);
  };

  const makeRestoreRef = (vatAdminSvc, zoe) => {
    /** @type {(ref: import\('./externalTypes.js').ManifestBundleRef) => Promise<Installation<unknown>>} */
    const defaultRestoreRef = async bundleRef => {
      // extract-proposal.js creates these records, and bundleName is
      // the optional name under which the bundle was installed into
      // config.bundles
      const bundleIdP =
        'bundleName' in bundleRef
          ? E(vatAdminSvc).getBundleIDByName(bundleRef.bundleName)
          : bundleRef.bundleID;
      const bundleID = await bundleIdP;
      const label = bundleID.slice(0, 8);
      return E(zoe).installBundleID(bundleID, label);
    };
    return defaultRestoreRef;
  };

  /** @param {ChainBootstrapSpace & BootstrapPowers & { evaluateBundleCap: any }} powers */
  const coreProposalBehavior = async powers => {
    // NOTE: `powers` is expected to match or be a superset of the above `permits` export,
    // which should therefore be kept in sync with this deconstruction code.
    // HOWEVER, do note that this function is invoked with at least the *union* of powers
    // required by individual moduleBehaviors declared by the manifest getter, which is
    // necessary so it can use `runModuleBehaviors` to provide the appropriate subset to
    // each one (see ./writeCoreEvalParts.js).
    // Handle `powers` with the requisite care.
    const {
      consume: { vatAdminSvc, zoe, agoricNamesAdmin },
      evaluateBundleCap,
      installation: { produce: produceInstallations },
      modules: {
        utils: { runModuleBehaviors },
      },
    } = powers;

    // Get the on-chain installation containing the manifest and behaviors.
    log('evaluateBundleCap', {
      manifestBundleRef,
      manifestGetterName,
      vatAdminSvc,
    });
    let bcapP;
    if ('bundleName' in manifestBundleRef) {
      bcapP = E(vatAdminSvc).getNamedBundleCap(manifestBundleRef.bundleName);
    } else if ('bundleID' in manifestBundleRef) {
      bcapP = E(vatAdminSvc).getBundleCap(manifestBundleRef.bundleID);
    } else {
      const keys = Reflect.ownKeys(manifestBundleRef).map(key =>
        typeof key === 'string' ? JSON.stringify(key) : String(key),
      );
      const keysStr = `[${keys.join(', ')}]`;
      throw Error(
        `bundleRef must have own bundleName or bundleID, missing in ${keysStr}`,
      );
    }
    const bundleCap = await bcapP;

    const proposalNS = await evaluateBundleCap(bundleCap);

    // Get the manifest and its metadata.
    log('execute', {
      manifestGetterName,
      bundleExports: Object.keys(proposalNS),
    });
    const restoreRef = customRestoreRef || makeRestoreRef(vatAdminSvc, zoe);
    const {
      manifest,
      options: rawOptions,
      installations: rawInstallations,
    } = await proposalNS[manifestGetterName](
      harden({ restoreRef }),
      ...manifestGetterArgs,
    );

    // Await promises in the returned options and installations records.
    const [options, installations] = await Promise.all(
      [rawOptions, rawInstallations].map(shallowlyFulfilled),
    );

    // Publish the installations for our dependencies.
    const installationEntries = entries(installations || {});
    if (installationEntries.length > 0) {
      const installAdmin = E(agoricNamesAdmin).lookupAdmin('installation');
      await Promise.all(
        installationEntries.map(([key, value]) => {
          produceInstallations[key].reset();
          produceInstallations[key].resolve(value);
          return E(installAdmin).update(key, value);
        }),
      );
    }

    // Evaluate the manifest.
    return runModuleBehaviors({
      // Remember that `powers` may be arbitrarily broad.
      allPowers: powers,
      behaviors: proposalNS,
      manifest: customManifest || manifest,
      makeConfig: (name, _permit) => {
        log('coreProposal:', name);
        return { options };
      },
    });
  };

  return coreProposalBehavior;
})({ manifestBundleRef, getManifestCall, customManifest, E });
behavior;
