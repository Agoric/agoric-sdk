#!/usr/bin/env -S node --import ts-blank-space/register
/** @file Fetch canonical chain info to generate the minimum needed for agoricNames */
import { ChainRegistryClient } from '@chain-registry/client';
import fsp from 'node:fs/promises';
import path from 'node:path';
import prettier from 'prettier';
import { convertChainInfo } from '../src/utils/registry.js';

const networkType = process.argv[2] || '';
const isMain = !networkType || networkType === 'mainnet';

// XXX script assumes it's run from the package path
// XXX .json would be more apt; UNTIL https://github.com/endojs/endo/issues/2110
const outputFile = isMain
  ? 'src/fetched-chain-info.js'
  : `src/fetched-chain-info-${networkType}.js`;

/**
 * Names for which to fetch info
 */
export const chainPatterns: (string | [string, string | RegExp])[] = [
  'agoric',
  'archway',
  'axelar',
  'beezee',
  'carbon',
  'celestia',
  'coreum',
  'cosmoshub',
  'crescent',
  'doravota',
  'dydx',
  'dymension',
  ['empowerchain', 'empower'],
  'evmos',
  'haqq',
  'injective',
  'juno',
  'kava',
  'kujira',
  'lava',
  'migaloo',
  'neutron',
  'nibiru',
  'noble',
  'nolus',
  'omniflixhub',
  'osmosis',
  'persistence',
  'planq',
  'provenance',
  'pryzm',
  'quicksilver',
  'secretnetwork',
  'sei',
  'shido',
  'sifchain',
  'stargaze',
  'stride',
  'terra2',
  'titan',
  'umee',
] as const;

const pathSuffix = isMain ? '' : networkType;
const directoryUrl = `https://api.github.com/repos/cosmos/chain-registry/contents/${pathSuffix}?ref=master`;
const fetched = await fetch(directoryUrl);
if (!fetched.ok) {
  throw Error(
    `${fetched.status} ${fetched.statusText} while fetching ${directoryUrl}`,
  );
}
const directoryJson = await fetched.json();
const entryNames = directoryJson.map(entry => entry.name);

const remainingPatterns = new Map(
  chainPatterns.map(pattern =>
    Array.isArray(pattern) ? pattern : [pattern, pattern],
  ) as [string, string | RegExp][],
);

const stemToEntry = new Map();
for (const entryName of entryNames) {
  for (const [stem, pattern] of remainingPatterns.entries()) {
    if (typeof pattern === 'string') {
      if (entryName.includes(pattern)) {
        stemToEntry.set(stem, entryName);
        remainingPatterns.delete(stem);
      }
    } else if (pattern.test(entryName)) {
      stemToEntry.set(stem, entryName);
      remainingPatterns.delete(stem);
    }
  }
}
const entryToStem = new Map([...stemToEntry.entries()].map(([k, v]) => [v, k]));
const chainNames = [...stemToEntry.values()];

const urlSuffix = isMain ? '' : `/${networkType}`;
const baseUrl = `https://raw.githubusercontent.com/cosmos/chain-registry/master${urlSuffix}`;
const client = new ChainRegistryClient({
  chainNames,
  baseUrl,
});

// chain info, assets and ibc data will be downloaded dynamically by invoking fetchUrls method
await client.fetchUrls();

const chainInfo = await convertChainInfo(
  client,
  chainName => entryToStem.get(chainName) ?? chainName,
);

const record = JSON.stringify(chainInfo, null, 2);
const scriptName = path.basename(process.argv[1]);
const src = `/** @file Generated by ${[scriptName, ...process.argv.slice(2)].join(' ')} */\nexport default /** @type {const} */ (${record});`;
const prettySrc = await prettier.format(src, {
  parser: 'babel', // 'typescript' fails to preserve parens for typecast
  singleQuote: true,
  trailingComma: 'all',
});
await fsp.writeFile(outputFile, prettySrc);

console.log(`Wrote ${outputFile}`);
console.log(`Remaining patterns:`, [...remainingPatterns.entries()]);
