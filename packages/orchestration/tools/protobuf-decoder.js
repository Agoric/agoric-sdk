/* eslint-env node */
/* eslint-disable -- generated by Sonnet, easier to leave alone */

const WIRE_TYPES = {
  VARINT: 0,
  FIXED64: 1,
  LENGTH_DELIMITED: 2,
  START_GROUP: 3,
  END_GROUP: 4,
  FIXED32: 5,
};

function decodeVarint(buffer, offset) {
  let result = 0n;
  let shift = 0;
  let byte;

  do {
    if (offset >= buffer.length) {
      throw new Error('Buffer overflow while decoding varint');
    }
    byte = buffer[offset];
    result |= BigInt(byte & 0x7f) << BigInt(shift);
    shift += 7;
    offset++;
  } while (byte & 0x80);

  return { value: result, bytesRead: shift / 7 };
}

function decodeFixed32(buffer, offset) {
  if (offset + 4 > buffer.length) {
    throw new Error('Buffer overflow while decoding fixed32');
  }
  return {
    value: buffer.readUInt32LE(offset),
    bytesRead: 4,
  };
}

function decodeFixed64(buffer, offset) {
  if (offset + 8 > buffer.length) {
    throw new Error('Buffer overflow while decoding fixed64');
  }
  const low = buffer.readUInt32LE(offset);
  const high = buffer.readUInt32LE(offset + 4);
  return {
    value: BigInt(high) * 2n ** 32n + BigInt(low),
    bytesRead: 8,
  };
}

function decodeString(buffer, offset, length) {
  if (offset + length > buffer.length) {
    throw new Error('Buffer overflow while decoding string');
  }
  return {
    value: buffer.toString('utf8', offset, offset + length),
    bytesRead: length,
  };
}

function decodeField(buffer, offset) {
  const tag = decodeVarint(buffer, offset);
  offset += tag.bytesRead;

  const fieldNumber = Number(tag.value >> 3n);
  const wireType = Number(tag.value & 0x7n);

  let value;
  let bytesRead;

  switch (wireType) {
    case WIRE_TYPES.VARINT:
      ({ value, bytesRead } = decodeVarint(buffer, offset));
      break;
    case WIRE_TYPES.FIXED64:
      ({ value, bytesRead } = decodeFixed64(buffer, offset));
      break;
    case WIRE_TYPES.LENGTH_DELIMITED:
      const length = decodeVarint(buffer, offset);
      offset += length.bytesRead;
      // Try to decode as a nested message first
      try {
        ({ value, bytesRead } = decodeProtobuf(
          buffer.slice(offset, offset + Number(length.value)),
        ));
      } catch (e) {
        // If it fails, decode as a string
        ({ value, bytesRead } = decodeString(
          buffer,
          offset,
          Number(length.value),
        ));
      }
      bytesRead += length.bytesRead;
      break;
    case WIRE_TYPES.FIXED32:
      ({ value, bytesRead } = decodeFixed32(buffer, offset));
      break;
    default:
      throw new Error(`Unsupported wire type: ${wireType}`);
  }

  return {
    fieldNumber,
    wireType,
    value,
    bytesRead: tag.bytesRead + bytesRead,
  };
}

function getFieldName(fieldNumber, wireType) {
  const typePrefix =
    wireType === WIRE_TYPES.LENGTH_DELIMITED
      ? 'subMessage'
      : wireType === WIRE_TYPES.VARINT
        ? 'int'
        : wireType === WIRE_TYPES.FIXED32
          ? 'fixed32'
          : wireType === WIRE_TYPES.FIXED64
            ? 'fixed64'
            : 'string';
  return `${typePrefix}_${fieldNumber}`;
}

/**
 * Decodes a protobuf message from the given buffer.
 *
 * @param {Buffer} buffer
 */
export function decodeProtobuf(buffer) {
  let offset = 0;
  const message = {};

  while (offset < buffer.length) {
    const field = decodeField(buffer, offset);
    const fieldName = getFieldName(field.fieldNumber, field.wireType);
    message[fieldName] = field.value;
    offset += field.bytesRead;
  }

  return { value: message, bytesRead: offset };
}
/**
 * Decodes a protobuf message from the given base64-encoded data.
 *
 * @param {string} base64String
 */
export function decodeProtobufBase64(base64String) {
  const buffer = Buffer.from(base64String, 'base64');
  return decodeProtobuf(buffer);
}
