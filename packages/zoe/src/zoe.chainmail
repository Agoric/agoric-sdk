/**
 * Zoe is a long-lived and well-trusted contract that enforces
 * offer safety for the contracts that run on it. The ZoeService is the
 * client- or user-facing Zoe API. There is also a separate API exposed
 * to the contracts.
 */

/**
 * These interfaces are defined in ERTP/src/amountMath.chainmail and ERTP/src/issuer.chainmail:
 * Issuer, AmountMath, Payment
 */


/**
 * A handle is an object which is only interesting for its (unique and unforgeable)
 * identity. It is often used as a key on (Weak)Maps
 */
interface Handle(T){
  /* a handle has no property */
}

interface Invite: Payment(InviteRecord);

struct InviteRecord ( ) {
  handle: Handle(Offer); // pending a decision on https://github.com/Agoric/agoric-sdk/issues/805
  instanceHandle: Handle(Instance);
}

/**
 * Keywords are strings that respect the following JavaScript Regexp: 
 * /^[A-Z][a-zA-Z0-9_$]*$/
 * In plain English, it means a Keyword starts with an uppercase ASCII letter
 * and is followed by any number of letters (uppercase and lowercase), numbers, 
 * or the "_" and "$" signs
 */
interface Keyword: String;

interface IssuerKeywordRecord{
  [Keyword]: Issuer;
}


interface ZoeService {

  /**
   * Zoe has a single `inviteIssuer` for the entirety of its lifetime. 
   * By having a reference to Zoe, a user can get the `inviteIssuer` 
   * and thus validate any `invite` they receive from someone else. The
   * mint associated with the inviteIssuer creates the ERTP payments 
   * that represent the right to interact with a smart contract in 
   * particular ways.
   */
  getInviteIssuer() -> (Issuer);

  /**
   * Create an installation by safely evaluating the code and
   * registering it with Zoe. Returns an installationHandle. 
   */
  install(code :String, moduleFormat :String) -> (Handle(Installation));
  
  /** 
   * Zoe is long-lived. We can use Zoe to create smart contract
   * instances by specifying a particular contract installation to 
   * use, as well as the `issuerKeywordRecord` and `terms` of the contract. The
   * `issuerKeywordRecord` is a record mapping string names (keywords) to issuers,
   * such as `{ Asset: simoleanIssuer}`. (Note that the keywords must
   * begin with a capital letter and must be ASCII.) Parties to the
   * contract will use the keywords to index their proposal and
   * their payments.
   * The payout users receive from Zoe will be in the form of an object
   * with keywords as keys. Terms are the arguments to the contract,
   * such as the number of bids an auction will wait for before closing.
   * Terms are up to the discretion of the smart contract. We get back
   * an invite (an ERTP payment) to participate in the contract.
   */
  makeInstance(installationHandle :Handle(Installation), issuerKeywordRecord :IssuerKeywordRecord, terms :Object) -> (Invite);
  
  /**
   * Credibly get information about the instance (such as the installation
   * and terms used).
   */
  getInstanceRecord(instanceHandle :Handle(Instance)) -> (InstanceRecord);

  /** 
   * To redeem an invite, the user normally provides a proposal (their rules for the
   * offer) as well as payments to be escrowed by Zoe.  If either the proposal or payments
   * would be empty, indicate this by omitting that argument or passing undefined, rather
   * than passing an empty record.
   * 
   * The proposal has three parts: `want` and `give` are used 
   * by Zoe to enforce offer safety, and `exit` is used to specify
   * the extent of payout liveness that Zoe can guarantee.
   * `want` and `give` are objects with keywords as keys and amounts
   * as values. `payments` is a record with keywords as keys,
   * and the values are the actual payments to be escrowed. A payment
   * is expected for every rule under `give`.
   */
  redeem (invite :Invite, proposal :Proposal, payments :PaymentKeywordRecord)) -> (SeatAndPayout);
}

/**
 * This is returned by a call to `redeem` on Zoe.
 * A seat is an arbitrary object whose methods allow the user to take
 * certain actions in a contract. The payout is a promise that resolves
 * to an object which has keywords as keys and promises for payments
 * as values. Note that while the payout promise resolves when an offer
 * is completed, the promise for each payment resolves after the remote
 * issuer successfully withdraws the payment.
 */
struct SeatAndPayout ( ) {
  seat :Object;
  payout :Promise(PaymentPromiseKeywordRecord); 
  cancelObj? :CancelObj; /* exists only when exit is 'onDemand' */
  /* this may be renamed to complete: https://github.com/Agoric/agoric-sdk/issues/835  */
}

interface CancelObj () {
  cancel();
}

struct Proposal ( ) {
  want :AmountKeywordRecord;
  give :AmountKeywordRecord;
  exit :ExitRule;
}

/**
 * The keys are keywords, and the values are amounts. For example:
 * { Asset: amountMath.make(5), Price: amountMath.make(9) }
 */
struct AmountKeywordRecord ( ) {
  [Keyword]: AmountMath;
}

struct PaymentKeywordRecord ( ){
  [Keyword]: Payment;
}

struct PaymentPromiseKeywordRecord ( ) {
  [Keyword]: Promise(Payment);
} 

/**
 * The possible keys are 'waived', 'onDemand', and 'afterDeadline'.
 * `timer` and `deadline` only are used for the `afterDeadline` key.
 * The possible records are:
 * `{ waived: null }`
 * `{ onDemand: null }`
 * `{ afterDeadline: { timer :Timer<Deadline>, deadline :Deadline } }
 */
struct ExitRule ( ) {
  timer :Timer;
  deadline :Deadline;
}

interface InstanceRecord{
  installationHandle: Handle(Installation),
  publicAPI: any,
  terms: any,
  issuerKeywordRecord: IssuerKeywordRecord
}


interface ZoeContractFacet () {

  /** 
   * Instruct Zoe to try reallocating for the given offerHandles.
   * Reallocation is an array of AmountKeywordRecords, which are objects where
   * the keys are keywords and the values are amounts. The
   * amounts to be paid to the player who made the offer at the same
   * index in the offerHandles array. The reallocation will only happen if
   * 'offer safety' and conservation of rights are true, as enforced by Zoe.
   */
  reallocate (offerHandles :List(Handle(Offer)), reallocation :List(AmountKeywordRecord));

  /** 
   * Eject the offer, taking the current allocation for that offer and
   * creating payments to be returned to the user. No 'offer safety' checks are
   * done here because any previous reallocation performed those checks.
   */
  complete (offerHandles :List(Handle(Offer)));
  
  /** Create an invite using the Zoe inviteMint */
  makeInvite (seat :Object, customProperties :Object ) -> (Invite);

  /** 
   * Inform Zoe about new issuers. Returns a promise for acknowledging
   * when the issuer is added and ready.
   */
  addNewIssuer (issuer :Issuer, keyword :Keyword) -> (Promise(Undefined));

  /**
   * Expose the user-facing Zoe Service API to the contracts as well.
   */
  getZoeService ( ) -> (ZoeService);

  ////// The methods below are pure and have no side-effects. ////////

  /** Get the Zoe inviteIssuer */
  getInviteIssuer ( ) -> (Issuer);

  /** Get a list of local amountMath for each keyword in the
  sparseKeywords array */
  getAmountMaths (sparseKeywords :List(Keyword)) -> (AmountMathKeywordRecord));

  /** Divide the offerHandles into 'active' and 'inactive' lists */
  getOfferStatuses ( offerHandles :List(Handle(Offer))) ->
  (OfferStatusesRecord);

  /** 
   * Check if the offer is still active. This method does not throw
   * if the offer is inactive.
   */
  isOfferActive ( offerHandle :Handle(Offer) ) -> (Bool);

  /** Get a list of offer records */
  getOffers ( offerHandles :List(Handle(Offer))) -> (List(OfferRecord));

  /** Get the offer record */
  getOffer ( offerHandle :Handle(Offer)) -> (List(OfferRecord));

  /** Get the current allocation associated with the offerHandle */
  getCurrentAllocation ( offerHandle :Handle(Offer) ) -> (AmountKeywordRecord);

  /** Get instance record */
  getInstanceRecord ( ) -> InstanceRecord;

}

struct OfferRecord ( ) {
  handle: Handle(Offer)
  instanceHandle: Handle(Instance);
  proposal :Proposal;
}

/**
 * `active` and `inactive` lists of offerHandles.
 */
 struct OfferStatusesRecord ( ) {
  active :List(Handle(Offer));
  inactive :List(Handle(Offer));
}
