#!/usr/bin/env node
// @ts-check

/* eslint-env node */
const { spawnSync } = require('child_process');
const fsp = require('fs/promises');
const path = require('path');
const assert = require('node:assert/strict');
const process = require('process');
const { TelescopeBuilder } = require('@hyperweb/telescope');
const rimraf = require('rimraf').rimrafSync;
const { getBaseTelescopeOptions } = require('../tools/telescope-options.cjs');
const {
  applyTelescopeFixes,
  detectGnuSed,
  fixTypeImportForVerbatim,
} = require('../tools/telescope-cleanup.cjs');

const protoDirs = [path.join(__dirname, '/../proto')];
const outPath = path.join(__dirname, '../src/codegen');
rimraf(outPath);

/**
 * @type {import('@hyperweb/telescope').TelescopeInput}
 */
const input = {
  protoDirs,
  outPath,
  options: getBaseTelescopeOptions(),
};

const builder = new TelescopeBuilder(input);

const strcmp = (a, b) => {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
};

const createTypeFromUrl = async () => {
  const { store } = builder;
  const fileExports = {};
  for (const proto of store.getProtos()) {
    // console.log(proto);
    if (!proto.traversed) {
      continue;
    }
    const typeUrlPrefix = `/${proto.proto.package}.`;
    const parsedExports = proto.traversed?.parsedExports;
    if (!parsedExports) {
      continue;
    }
    const exports = Object.keys(parsedExports).sort(strcmp);
    if (!exports.length) {
      continue;
    }

    const importFrom = `./${proto.filename.replace(/\.proto$/, '.js')}`;
    fileExports[importFrom] = exports.map(exp => [
      `${typeUrlPrefix}${exp}`,
      exp,
    ]);
  }

  const sortedEntries = Object.entries(fileExports).sort(([a], [b]) =>
    strcmp(a, b),
  );

  const props = [];
  const imports = {};
  for (const [importFrom, exports] of sortedEntries) {
    const imp = importFrom.replaceAll(/[\/\.]/g, str => {
      switch (str) {
        case '/':
          return '$';
        case '.':
          return '_';
        default:
          assert.fail(`unrecognized string ${str}`);
      }
    });
    imports[imp] = importFrom;
    for (const [typeUrl, exp] of exports) {
      props.push(`  ${JSON.stringify(typeUrl)}: ${imp}.${exp};`);
    }
  }

  // Render the output.
  const out = [];
  out.push(
    `\
// DO NOT EDIT; generated by ${path.relative(process.cwd(), __filename)}
    `,
  );
  for (const [imp, importFrom] of Object.entries(imports)) {
    out.push(`import type * as ${imp} from ${JSON.stringify(importFrom)};`);
  }
  out.push('', `export type TypeFromUrl = {`, ...props, `};`, '');
  return out.join('\n');
};

builder
  .build()
  .then(async () => {
    const typeFromUrlContents = await createTypeFromUrl();
    // CAVEAT: This file needs to be a `.ts` instead of `.d.ts` or else `tsc`
    // won't compile its types into the dist output.
    const typeFromUrlFile = path.join(outPath, 'typeFromUrl.ts');
    await fsp.writeFile(typeFromUrlFile, typeFromUrlContents);

    console.log('ðŸ”¨ code generated by Telescope');

    // for all files under codegen/ replace "import { JsonSafe" with "import type { JsonSafe"
    const gnuSed = detectGnuSed();
    fixTypeImportForVerbatim('./src/codegen', gnuSed);
    console.log('ðŸ”§ type keyword added');

    const repoRoot = path.join(__dirname, '..', '..', '..');
    const srcFromRoot = path.relative(
      repoRoot,
      path.join(__dirname, '..', 'src'),
    );
    const codegenFromRoot = path.join(srcFromRoot, 'codegen');
    const prettierResult = spawnSync(
      'yarn',
      ['run', '-T', 'prettier', '--write', codegenFromRoot],
      {
        cwd: repoRoot,
        stdio: 'inherit',
      },
    );
    if (prettierResult.error) {
      throw prettierResult.error;
    }
    assert.equal(prettierResult.status, 0);
    console.log('ðŸ’… code formatted by Prettier');

    const cleanedFiles = await applyTelescopeFixes({
      outPath,
      includeSigningClientParamsCleanup: true,
    });
    if (cleanedFiles.length > 0) {
      const prettierHelpersResult = spawnSync(
        'yarn',
        [
          'run',
          '--top-level',
          'prettier',
          '--write',
          ...cleanedFiles.map(file =>
            path.relative(path.join(__dirname, '..'), file),
          ),
        ],
        {
          cwd: path.join(__dirname, '..'),
          stdio: 'inherit',
        },
      );
      assert.equal(prettierHelpersResult.status, 0);
    }
    console.log('ðŸ§¹ cleaned generated helper compatibility imports');

    console.log('â„¹ï¸ `yarn build && yarn test` to test it.');
  })
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
