syntax = "proto3";
package agoric.swingset;

import "amino/amino.proto";
import "cosmos/msg/v1/msg.proto";
import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";
import "agoric/swingset/swingset.proto";

option go_package = "github.com/Agoric/agoric-sdk/golang/cosmos/x/swingset/types";

// Transactions.
service Msg {
  // Install a JavaScript sources bundle on the chain's SwingSet controller.
  rpc InstallBundle(MsgInstallBundle) returns (MsgInstallBundleResponse);
  // Send a chunk of a bundle (or other artifact) to tolerate RPC message size limits.
  rpc SendChunk(MsgSendChunk) returns (MsgSendChunkResponse);
  // Send inbound messages.
  rpc DeliverInbound(MsgDeliverInbound) returns (MsgDeliverInboundResponse);
  // Perform a low-privilege wallet action.
  rpc WalletAction(MsgWalletAction) returns (MsgWalletActionResponse);
  // Perform a wallet action that spends assets.
  rpc WalletSpendAction(MsgWalletSpendAction) returns (MsgWalletSpendActionResponse);
  // Provision a new endpoint.
  rpc Provision(MsgProvision) returns (MsgProvisionResponse);
  // Execute a core evaluation.
  rpc CoreEval(MsgCoreEval) returns (MsgCoreEvalResponse);
}

// MsgDeliverInbound defines an SDK message for delivering an eventual send
message MsgDeliverInbound {
  option (gogoproto.equal) = false;
  option (amino.name)      = "swingset/DeliverInbound";

  repeated string messages = 1 [
    (amino.dont_omitempty) = true,
    (amino.encoding)       = "null_slice_as_empty",
    (gogoproto.jsontag)    = "messages",
    (gogoproto.moretags)   = "yaml:\"messages\""
  ];
  repeated uint64 nums = 2 [
    (amino.dont_omitempty) = true,
    (amino.encoding)       = "null_slice_as_empty",
    (gogoproto.jsontag)    = "nums",
    (gogoproto.moretags)   = "yaml:\"nums\""
  ];
  uint64 ack = 3 [(amino.dont_omitempty) = true, (gogoproto.jsontag) = "ack", (gogoproto.moretags) = "yaml:\"ack\""];
  bytes  submitter = 4 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "submitter",
    (gogoproto.moretags) = "yaml:\"submitter\""
  ];
}

// MsgDeliverInboundResponse is an empty reply.
message MsgDeliverInboundResponse {}

// MsgWalletAction defines an SDK message for the on-chain wallet to perform an
// action that *does not* spend any assets (other than gas fees/stamps).  This
// message type is typically protected by feegrant budgets.
message MsgWalletAction {
  option (gogoproto.equal) = false;
  option (amino.name)      = "swingset/WalletAction";

  bytes owner = 1 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "owner",
    (gogoproto.moretags) = "yaml:\"owner\""
  ];

  // The action to perform, as JSON-stringified marshalled data.
  string action = 2;
}

// MsgWalletActionResponse is an empty reply.
message MsgWalletActionResponse {}

// MsgWalletSpendAction defines an SDK message for the on-chain wallet to
// perform an action that *does spend the owner's assets.*  This message type is
// typically protected by explicit confirmation by the user.
message MsgWalletSpendAction {
  option (gogoproto.equal) = false;
  option (amino.name)      = "swingset/WalletSpendAction";

  bytes owner = 1 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "owner",
    (gogoproto.moretags) = "yaml:\"owner\""
  ];

  // The action to perform, as JSON-stringified marshalled data.
  string spend_action = 2;
}

// MsgWalletSpendActionResponse is an empty reply.
message MsgWalletSpendActionResponse {}

// MsgProvision defines an SDK message for provisioning a client to the chain
message MsgProvision {
  option (gogoproto.equal) = false;
  option (amino.name)      = "swingset/Provision";

  string nickname = 1 [(gogoproto.jsontag) = "nickname", (gogoproto.moretags) = "yaml:\"nickname\""];
  bytes  address  = 2 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "address",
    (gogoproto.moretags) = "yaml:\"address\""
  ];
  repeated string power_flags = 3 [
    (amino.dont_omitempty) = true,
    (amino.encoding)       = "null_slice_as_empty",
    (amino.field_name)     = "powerFlags",
    (gogoproto.customname) = "PowerFlags",
    (gogoproto.jsontag)    = "powerFlags",
    (gogoproto.moretags)   = "yaml:\"powerFlags\""
  ];
  bytes submitter = 4 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "submitter",
    (gogoproto.moretags) = "yaml:\"submitter\""
  ];
}

// MsgProvisionResponse is an empty reply.
message MsgProvisionResponse {}

// MsgInstallBundle carries a signed bundle to SwingSet.
// The fields `bundle`, `compressed_bundle`, and `chunked_artifact` are mutually
// exclusive, and exactly one must be present based on what is being submitted:
// * `bundle` for a complete and uncompressed bundle
// * `compressed_bundle` for a complete and compressed bundle
// * `chunked_artifact` for a manifest of chunks to be submitted in subsequent
//   messages.
message MsgInstallBundle {
  // Until agoric-upgrade-22 this message didn't have an amino name
  // but no clients actually used amino encoding
  option (amino.name) = "swingset/InstallBundle";

  string bundle = 1
      [(amino.dont_omitempty) = true, (gogoproto.jsontag) = "bundle", (gogoproto.moretags) = "yaml:\"bundle\""];
  bytes submitter = 2 [
    (amino.encoding)     = "legacy_address",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "submitter",
    (gogoproto.moretags) = "yaml:\"submitter\""
  ];
  // Default compression algorithm is gzip.
  bytes compressed_bundle = 3 [
    (amino.dont_omitempty) = true,
    (amino.field_name)     = "compressedBundle",
    (gogoproto.jsontag)    = "compressedBundle",
    (gogoproto.moretags)   = "yaml:\"compressedBundle\""
  ];
  // Total size in bytes of the bundle artifact, before compression and after
  // decompression.
  int64 uncompressed_size = 4 [
    (amino.dont_omitempty) = true,
    (amino.field_name)     = "uncompressedSize",
    (gogoproto.jsontag)    = "uncompressedSize"
  ];
  // Declaration of a chunked bundle.
  ChunkedArtifact chunked_artifact = 5 [
    (amino.field_name)   = "chunkedArtifact",
    (gogoproto.jsontag)  = "chunkedArtifact,omitempty",
    (gogoproto.moretags) = "yaml:\"chunkedArtifact\""
  ];
}

// MsgCoreEval defines an SDK message for a core eval.
message MsgCoreEval {
  option (cosmos.msg.v1.signer) = "authority";
  option (amino.name)           = "cosmos-sdk/x/swingset/MsgCoreEval";

  // authority is the address that controls the module (defaults to x/gov unless overwritten).
  string authority = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  // The JSON-stringified core bootstrap permits to grant to the jsCode, as the
  // `powers` endowment.
  string json_permits = 2 [(gogoproto.moretags) = "yaml:\"json_permits\""];

  // Evaluate this JavaScript code in a Compartment endowed with `powers` as
  // well as some powerless helpers.
  string js_code = 3 [(gogoproto.moretags) = "yaml:\"js_code\""];
}

// MsgCoreEvalResponse is an empty reply.
message MsgCoreEvalResponse {
  // The result of the core eval.
  string result = 1 [(gogoproto.moretags) = "yaml:\"result\""];
}

// MsgInstallBundleResponse is either an empty acknowledgement that a bundle
// installation message has been queued for the SwingSet kernel's
// consideration, or (for MsgInstallBundle requests that have a chunked artifact
// manifest instead of a compressed or uncompressed bundle) a container for the
// chunked artifact identifier to be included in subsequent MsgSendChunk
// messages.
message MsgInstallBundleResponse {
  // The assigned identifier for a chunked artifact, if the caller is expected
  // to call back with MsgSendChunk messages.
  uint64 chunked_artifact_id = 1 [
    (amino.field_name)   = "chunkedArtifactId",
    (gogoproto.jsontag)  = "chunkedArtifactId",
    (gogoproto.moretags) = "yaml:\"chunkedArtifactId\""
  ];
}

// MsgSendChunk carries a chunk of an artifact through RPC to the chain.
// Individual chunks are addressed by the chunked artifact identifier and
// the zero-based index of the chunk among all chunks as mentioned in the
// manifest provided to MsgInstallBundle.
message MsgSendChunk {
  uint64 chunked_artifact_id = 1 [
    (amino.field_name)   = "chunkedArtifactId",
    (gogoproto.jsontag)  = "chunkedArtifactId",
    (gogoproto.moretags) = "yaml:\"chunkedArtifactId\""
  ];
  bytes submitter = 2 [
    (amino.encoding)     = "legacy_address",
    (amino.field_name)   = "submitter",
    (gogoproto.casttype) = "github.com/cosmos/cosmos-sdk/types.AccAddress",
    (gogoproto.jsontag)  = "submitter",
    (gogoproto.moretags) = "yaml:\"submitter\""
  ];
  uint64 chunk_index = 3 [
    (amino.field_name)   = "chunkIndex",
    (gogoproto.jsontag)  = "chunkIndex",
    (gogoproto.moretags) = "yaml:\"chunkIndex\""
  ];
  bytes chunk_data = 4 [
    (amino.field_name)   = "chunkData",
    (gogoproto.jsontag)  = "chunkData",
    (gogoproto.moretags) = "yaml:\"chunkData\""
  ];
}

// MsgSendChunkResponse is an acknowledgement that a chunk has been received by
// the chain.
message MsgSendChunkResponse {
  uint64 chunked_artifact_id = 1 [
    (amino.field_name)   = "chunkedArtifactId",
    (gogoproto.jsontag)  = "chunkedArtifactId",
    (gogoproto.moretags) = "yaml:\"chunkedArtifactId\""
  ];
  // The current state of the chunk.
  ChunkInfo chunk = 2
      [(amino.field_name) = "chunk", (gogoproto.jsontag) = "chunk", (gogoproto.moretags) = "yaml:\"chunk\""];
}
