name: Test all Packages

# run on all PRs (even the ones that target other branches)

on:
  pull_request:
  merge_group:
  push:
    branches: [master]
  schedule:
    # We start a little earlier to give our build cache time to populate.
    - cron: "47 5 * * *"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AGORIC_AVA_USE_TAP: true
  NODE_V8_COVERAGE: coverage
  TEST_COLLECT: "tee -a _testoutput.txt"

# this is required, since explicitly setting bash as shell enables pipefail, which is not
# on by default.  This is required to fail correctly when teeing output to a file to collect
# test instrumentation
defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: ["node-new", "node-old"]
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: "true"
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.node-version }}

  dependency-graph:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install graphviz
        run: sudo apt install -y graphviz

      # This is now redundant with Lerna's --reject-cycles but keep it here so we have
      # test coverage of this script we use for visualizing the dep graph.
      - name: Check for cycles
        run: scripts/check-dependency-cycles.sh

      # install node_modules
      - uses: ./.github/actions/restore-node
        with:
          node-version: "node-new"

      # Releasing SDK builds all packages in this order during `lerna publish`.
      # Due to ambient types, certain build orders (from the dependency graph)
      # may break the type resolution. Run this in the PR to find out before
      # attempting to merge to master. This takes about 1min locally and since
      # this job is about 30s in CI doing it here doesn't add to wall wait for
      # CI resolution.
      #
      # We prepack only because full pack removes the declarations, relying on
      # ambient resolution in the repo filesystem which will not be available
      # when the packages are pulled from npm.
      #
      # After that test, we postpack to avoid putting the prepack artifacts in
      # the cache maintained by restore-node, since they are not .gitignored and
      # thus will fail restore-node's check for a clean repo when the cache is
      # restored.
      - name: Pack packages without ambient type resolution
        run: |
          # Check that all exports work before packing
          scripts/packing/verify-package-exports.mjs --quiet --mode=scm
          # prepack must be in order to verify type dependency availability
          yarn lerna run --reject-cycles --concurrency 1 prepack
          # check for broken exports in the packed builds
          scripts/packing/verify-package-exports.mjs --quiet --mode=packed
          # postpack has to be serial to correctly restore the .js files deleted in prepack
          yarn lerna run --reject-cycles --concurrency 1 postpack

  ##################
  # Lint tests
  lint-primary:
    timeout-minutes: 45 # Since Node 22, it's sometimes longer than 20min
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: "node-new"

      # eslint and tsc
      # XXX running tsc in every package is slow and redundant.
      - run: yarn lint:packages

  # A second job for what's not covered in primary
  lint-rest:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: "node-new"

      - name: lint repo format
        run: yarn lint:format

      - run: yarn lint:package-names

      - run: yarn constraints

      # Check some of a3p-integration in this job that runs on PRs instead of
      # waiting for the slow integration test that by default only runs in the
      # master merge check
      - name: Lint a3p-integration
        # FIXME restore `yarn lint` once client-utils in NPM is compatible with HEAD
        # (after this change merges to master and the `dev` version is published)
        run: yarn install && yarn doctor
        working-directory: a3p-integration
      - name: build A3P submissions
        run: yarn run build:submissions
        working-directory: a3p-integration

      # run the typecheck-quick that local dev can rely on for fast feedback
      - name: typecheck-quick
        run: yarn typecheck-quick

      # Attempt the doc generation to catch build errors before
      # landing on master
      - name: build API docs
        run: yarn docs
      - name: build API docs in markdown
        run: yarn docs:markdown-for-agoric-documentation-repo

  # Build the package lockfiles, and check that they are clean.
  check-lockfiles:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: "node-new"

      - name: Update package lockfiles
        run: scripts/update-package-locks.sh || exit 0

      - name: Check if lockfiles are changed
        run: |
          if bash ./.github/actions/restore-node/check-git-status.sh . false; then
            echo "No changes to lockfiles detected."
          else
            echo "Changes to lockfiles detected!"
            echo "Please run 'yarn build-lockfiles', commit the results, and push"
            exit 1
          fi

  ##################
  # Fast-running tests run as a group:
  test-quick:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT

      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE

      # We run separate steps for each package, to make it easier to drill down
      # into errors. If we wanted to just run everything, run 'yarn test' from
      # the top level.
      #
      # This list should include all packages, except ones that are in another
      #  category here, or that don't have a package.json.
      #- name: yarn test (everything)
      #  run: yarn ${{ steps.vars.outputs.test }}
      - name: yarn test (swing-store)
        if: (success() || failure())
        shell: bash
        run: |
          set +e
          trap 'echo "swing-store shell received SIGHUP"' HUP
          diag_module="$PWD/packages/swing-store/test/ava-process-diagnostics.js"
          export NODE_OPTIONS="--require=$diag_module ${NODE_OPTIONS:-}"

          show_coverage_state() {
            local cov_dir="$1"
            if [ -n "$cov_dir" ] && [ -d "$cov_dir" ]; then
              echo "coverage dir: $cov_dir"
              find "$cov_dir" -maxdepth 1 -type f -name '*.json' | wc -l
              du -sh "$cov_dir" || true
              find "$cov_dir" -maxdepth 1 -type f -name '*.json' -printf '%T@ %f\n' 2>/dev/null | sort -n | tail -n 5 || true
            else
              echo "coverage dir not present: ${cov_dir:-<unset>}"
            fi
          }

          run_ava_attempt() {
            local label="$1"
            local worker_mode="$2"
            local cov_mode="$3"
            local out_file="$4"
            local attempt_cov="${NODE_V8_COVERAGE:-}"
            local -a cmd=(node ../../node_modules/ava/entrypoints/cli.mjs)
            if [ "$worker_mode" = "no-workers" ]; then
              cmd+=(--no-worker-threads)
            fi
            if [ "$cov_mode" = "fresh" ]; then
              attempt_cov="$PWD/coverage-retry-${label// /-}-$RANDOM"
              mkdir -p "$attempt_cov"
            elif [ "$cov_mode" = "off" ]; then
              attempt_cov=""
            fi

            echo "--- attempt: $label ---"
            echo "attempt worker mode: $worker_mode"
            echo "attempt coverage mode: $cov_mode"
            if [ -n "$attempt_cov" ]; then
              echo "attempt NODE_V8_COVERAGE=$attempt_cov"
              NODE_V8_COVERAGE="$attempt_cov" "${cmd[@]}" > >(tee -a "$out_file") 2>&1
            else
              echo "attempt NODE_V8_COVERAGE=<unset>"
              env -u NODE_V8_COVERAGE "${cmd[@]}" > >(tee -a "$out_file") 2>&1
            fi
            local attempt_rc=$?
            echo "attempt exit code: $attempt_rc"
            show_coverage_state "$attempt_cov"
            return "$attempt_rc"
          }

          # include the following string for check-untested-packages.mjs to believe that this package is being tested
          # cd packages/swing-store && yarn ${{ steps.vars.outputs.test }}
          # now actually run this test command, so that we get the diagnostics on this package if it fails
          cd packages/swing-store || exit $?

          echo "::group::swing-store preflight diagnostics"
          echo "matrix.engine=${{ matrix.engine }}"
          echo "test target=${{ steps.vars.outputs.test }}"
          echo "node: $(node -v)"
          echo "yarn: $(yarn -v)"
          echo "pwd: $(pwd)"
          echo "NODE_OPTIONS: ${NODE_OPTIONS}"
          show_coverage_state "${NODE_V8_COVERAGE:-}"
          echo "repo-wide coverage json count so far:"
          find ../.. -type f -name 'coverage*.json' | wc -l
          echo "--- free -m ---"
          free -m || true
          echo "--- df -h . ---"
          df -h . || true
          echo "::endgroup::"

          if [ "${{ steps.vars.outputs.test }}" = "test" ]; then
            run_ava_attempt "main" "default" "default" "_testoutput.txt"
            rc=$?
            pipe_status=("$rc" 0)
          else
            yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
            pipe_status=("${PIPESTATUS[@]}")
            rc=0
            for ((idx=${#pipe_status[@]} - 1; idx >= 0; idx--)); do
              if [ "${pipe_status[$idx]}" -ne 0 ]; then
                rc="${pipe_status[$idx]}"
                break
              fi
            done
          fi

          if [ "$rc" -ne 0 ]; then
            echo "::group::swing-store failure diagnostics"
            echo "test command exit code: $rc"
            if [ "$rc" -eq 129 ]; then
              echo "exit 129 indicates SIGHUP"
            fi
            if [ "$rc" -eq 139 ]; then
              echo "exit 139 indicates SIGSEGV"
            fi
            echo "PIPESTATUS (test tee): ${pipe_status[*]}"
            echo "NODE_OPTIONS: ${NODE_OPTIONS}"
            echo "node: $(node -v)"
            echo "yarn: $(yarn -v)"
            echo "pwd: $(pwd)"
            echo "--- ulimit -a ---"
            ulimit -a || true
            echo "--- process tree (pstree) ---"
            pstree -pal "$$" || true
            echo "--- process list (filtered for test processes) ---"
            ps -eo pid,ppid,pgid,sid,stat,etime,pcpu,pmem,comm,args | grep -E '(PID|ava|node|yarn|tee)' || true
            echo "--- coverage state at failure ---"
            show_coverage_state "${NODE_V8_COVERAGE:-}"
            echo "--- last 200 lines of _testoutput.txt ---"
            tail -n 200 _testoutput.txt || true

            # Triangulation probes to isolate coverage-state and worker-thread effects.
            if [ "${{ matrix.engine }}" = "node-old" ] && [ "${{ steps.vars.outputs.test }}" = "test" ]; then
              run_ava_attempt "retry-a-same" "default" "default" "_testoutput_retry_a.txt"; echo "retry-a exit code: $?"
              run_ava_attempt "retry-b-cov-off" "default" "off" "_testoutput_retry_b.txt"; echo "retry-b exit code: $?"
              run_ava_attempt "retry-c-cov-fresh" "default" "fresh" "_testoutput_retry_c.txt"; echo "retry-c exit code: $?"
              run_ava_attempt "retry-d-nowork-same" "no-workers" "default" "_testoutput_retry_d.txt"; echo "retry-d exit code: $?"
              run_ava_attempt "retry-e-nowork-fresh" "no-workers" "fresh" "_testoutput_retry_e.txt"; echo "retry-e exit code: $?"
              echo "--- last 120 lines of retry outputs ---"
              for f in _testoutput_retry_*.txt; do
                [ -f "$f" ] || continue
                echo ">>> $f"
                tail -n 120 "$f" || true
              done
            fi
            echo "::endgroup::"
          fi
          exit "$rc"
      - name: upload swing-store crash artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: swing-store-diag-${{ matrix.engine }}-${{ github.run_id }}
          path: |
            packages/swing-store/_testoutput*.txt
            packages/swing-store/coverage-retry-*/
          if-no-files-found: ignore
      - name: yarn test (access-token)
        if: (success() || failure())
        run: cd packages/access-token && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (benchmark)
        if: (success() || failure())
        run: cd packages/benchmark && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (deployment)
        if: (success() || failure())
        run: cd packages/deployment && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (ERTP)
        if: (success() || failure())
        run: cd packages/ERTP && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (import-manager)
        if: (success() || failure())
        run: cd packages/import-manager && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (notifier)
        if: (success() || failure())
        run: cd packages/notifier && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (orchestration)
        if: (success() || failure())
        run: cd packages/orchestration && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (portfolio-api)
        if: (success() || failure())
        run: cd packages/portfolio-api && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (portfolio-deploy)
        if: (success() || failure())
        run: cd packages/portfolio-deploy && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (sparse-ints)
        if: (success() || failure())
        run: cd packages/sparse-ints && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (spawner)
        if: (success() || failure())
        run: cd packages/spawner && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (stat-logger)
        if: (success() || failure())
        run: cd packages/stat-logger && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (store)
        if: (success() || failure())
        run: cd packages/store && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (cosmic-proto)
        if: (success() || failure())
        run: cd packages/cosmic-proto && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (vow)
        if: (success() || failure())
        run: cd packages/vow && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (xsnap-lockdown)
        if: (success() || failure())
        run: cd packages/xsnap-lockdown && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (xsnap)
        if: (success() || failure())
        run: cd packages/xsnap && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (ymax-planner)
        if: (success() || failure())
        run: cd services/ymax-planner && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  # Verify that running `yarn codegen` in any package that defines it
  # does not produce changes. Only runs on pull requests.
  test-codegen:
    if: github.event_name == 'pull_request'
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: "true"

      - uses: ./.github/actions/restore-node
        with:
          node-version: "node-new"

      # Some codegen (e.g., cosmic-proto) depends on Go toolchain
      - uses: ./.github/actions/restore-golang
        with:
          go-version: "1.22"

      - name: Verify codegen idempotence
        shell: bash
        run: scripts/verify-codegen-idempotence.mjs

  test-quick2:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (agoric-cli)
        if: (success() || failure())
        run: cd packages/agoric-cli && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (async-flow)
        if: (success() || failure())
        run: cd packages/async-flow && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (base-zone)
        if: (success() || failure())
        run: cd packages/base-zone && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (builders)
        if: (success() || failure())
        run: cd packages/builders && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (cosmos)
        if: (success() || failure())
        run: cd golang/cosmos && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (cache)
        if: (success() || failure())
        run: cd packages/cache && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (casting)
        if: (success() || failure())
        run: cd packages/casting && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (client-utils)
        if: (success() || failure())
        run: cd packages/client-utils && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (create-dapp)
        run: cd packages/create-dapp && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (fast-usdc)
        if: (success() || failure())
        run: cd packages/fast-usdc && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (fast-usdc-contract)
        if: (success() || failure())
        run: cd packages/fast-usdc-contract && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (internal)
        if: (success() || failure())
        run: cd packages/internal && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (kmarshal)
        if: (success() || failure())
        run: cd packages/kmarshal && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (network)
        if: (success() || failure())
        run: cd packages/network && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (pegasus)
        if: (success() || failure())
        run: cd packages/pegasus && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (pola-io)
        if: (success() || failure())
        run: cd packages/pola-io && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (smart-wallet)
        if: (success() || failure())
        run: cd packages/smart-wallet && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (swingset-runner)
        if: (success() || failure())
        run: cd packages/swingset-runner && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (telemetry)
        if: (success() || failure())
        run: cd packages/telemetry && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (deploy-script-support)
        if: (success() || failure())
        run: cd packages/deploy-script-support && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (wallet)
        if: (success() || failure())
        run: cd packages/wallet && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (wallet/api)
        if: (success() || failure())
        run: cd packages/wallet/api && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (eslint-config)
        if: (success() || failure())
        run: cd packages/eslint-config && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (eslint-plugin)
        if: (success() || failure())
        run: cd packages/eslint-plugin && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (vat-data)
        if: (success() || failure())
        run: cd packages/vat-data && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (time)
        if: (success() || failure())
        run: cd packages/time && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (swingset-liveslots)
        if: (success() || failure())
        run: cd packages/swingset-liveslots && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (swingset-xsnap-supervisor)
        if: (success() || failure())
        run: cd packages/swingset-xsnap-supervisor && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (vats)
        if: (success() || failure())
        run: cd packages/vats && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (vm-config)
        if: (success() || failure())
        run: cd packages/vm-config && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: yarn test (zone)
        if: (success() || failure())
        run: cd packages/zone && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT

        # The meta-test!
      - name: Check for untested packages
        if: (success() || failure())
        run: node ./scripts/check-untested-packages.mjs

      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  ##############
  # Long-running tests are executed individually.
  test-fast-usdc-deploy:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in governance/package.json
        engine: ["node-new", "node-old"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (fast-usdc-deploy)
        if: (success() || failure())
        run: cd packages/fast-usdc-deploy && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-governance:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in governance/package.json
        engine: ["node-new", "node-old"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (governance)
        if: (success() || failure())
        run: cd packages/governance && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-portfolio-contract:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in portfolio-contract/package.json
        engine: ["node-new", "node-old"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (portfolio-contract)
        if: (success() || failure())
        run: cd packages/portfolio-contract && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-solo:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in solo/package.json
        engine: ["node-new", "node-old"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (solo)
        if: (success() || failure())
        run: cd packages/solo && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-cosmic-swingset:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in cosmic-swingset/package.json
        engine: ["node-new", "node-old", "xs"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT

      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - uses: ./.github/actions/restore-golang
        with:
          go-version: "1.22"
      - name: yarn test (cosmic-swingset)
        if: (success() || failure())
        run: cd packages/cosmic-swingset && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-inter-protocol:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # test:xs is noop in inter-protocol/package.json
        engine: ["node-new", "node-old"]
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (inter-protocol)
        if: (success() || failure())
        run: cd packages/inter-protocol && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-boot:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 40
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
        # Run parallel testing jobs, each executing a subset.
        node_index: [0, 1, 2, 3]
        total_nodes: [4] # the total number of nodes
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
          echo "CI_NODE_INDEX=${{ matrix.node_index }}" >> $GITHUB_ENV
          echo "CI_NODE_TOTAL=${{ matrix.total_nodes }}" >> $GITHUB_ENV

      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (boot)
        if: (success() || failure())
        run: cd packages/boot && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-swingset:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
        # Run parallel testing jobs, each executing a subset.
        node_index: [0, 1, 2, 3, 4]
        total_nodes: [5] # the total number of nodes
    steps:
      - name: set vars
        id: vars
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs' || 'test' }}" >> $GITHUB_OUTPUT
          echo "CI_NODE_INDEX=${{ matrix.node_index }}" >> $GITHUB_ENV
          echo "CI_NODE_TOTAL=${{ matrix.total_nodes }}" >> $GITHUB_ENV

      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
        id: restore-node
      - run: echo "ENDO_BRANCH=${{ steps.restore-node.outputs.endo-branch }}" >> $GITHUB_ENV
      # END-TEST-BOILERPLATE
      - name: yarn test (SwingSet)
        if: (success() || failure())
        run: cd packages/SwingSet && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      # explicitly test the XS worker, for visibility
      - name: yarn test (SwingSet XS Worker)
        if: (success() || failure()) && matrix.engine != 'xs'
        run: cd packages/SwingSet && yarn test:xs-worker | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-zoe-unit:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
    steps:
      - name: set vars
        id: vars
        # END-TEST-BOILERPLATE
        # XXX test:xs-unit is deprecated branch protection still expects it
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs-unit' || 'test:unit' }}" >> $GITHUB_OUTPUT
        # BEGIN-TEST-BOILERPLATE
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (zoe)
        if: (success() || failure())
        timeout-minutes: 30
        run: cd packages/zoe && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}

  test-zoe-swingset:
    # BEGIN-TEST-BOILERPLATE
    timeout-minutes: 30
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        engine: ["node-new", "node-old", "xs"]
    steps:
      - name: set vars
        id: vars
        # END-TEST-BOILERPLATE
        run: |
          echo "test=${{ matrix.engine == 'xs' && 'test:xs-worker' || 'test:swingset' }}" >> $GITHUB_OUTPUT
        # BEGIN-TEST-BOILERPLATE
      - uses: actions/checkout@v4
      - uses: ./.github/actions/restore-node
        with:
          node-version: ${{ matrix.engine }}
      # END-TEST-BOILERPLATE
      - name: yarn test (zoe)
        if: (success() || failure())
        timeout-minutes: 30
        run: cd packages/zoe && yarn ${{ steps.vars.outputs.test }} | $TEST_COLLECT
      - name: notify on failure
        if: failure() && github.event_name != 'pull_request'
        uses: ./.github/actions/notify-status
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          from: ${{ secrets.NOTIFY_EMAIL_FROM }}
          to: ${{ secrets.NOTIFY_EMAIL_TO }}
          password: ${{ secrets.NOTIFY_EMAIL_PASSWORD }}
      - uses: ./.github/actions/post-test
        if: (success() || failure())
        continue-on-error: true
        timeout-minutes: 4
        with:
          codecov-token: ${{ secrets.CODECOV_TOKEN }}
          gcp-credentials: ${{ secrets.GCP_CREDENTIALS }}
