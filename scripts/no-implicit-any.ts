#!/usr/bin/env -S node --import ts-blank-space/register

import fs from 'node:fs';
import path from 'node:path';
import { execaSync } from 'execa';

const usage = `Usage:
  scripts/no-implicit-any.ts count [--output <path>] [--tsconfig <path>]
  scripts/no-implicit-any.ts report [--input <path>] [--output <path>]

Commands:
  count   Run TypeScript with --noImplicitAny and write counts per file as TSV.
  report  Read a TSV generated by 'count' and print repo + package totals.
`;

/**
 * @param {string[]} argv
 */
const parseFlags = argv => {
  /** @type {Record<string, string>} */
  const flags = {};
  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i];
    if (!token.startsWith('--')) {
      throw new Error(`Unexpected argument: ${token}`);
    }
    const key = token.slice(2);
    const value = argv[i + 1];
    if (!value || value.startsWith('--')) {
      throw new Error(`Missing value for --${key}`);
    }
    flags[key] = value;
    i += 1;
  }
  return flags;
};

const DIAGNOSTIC_RE = /^(.*)\((\d+),(\d+)\): error TS(\d+): (.*)$/;
const IMPLICIT_ANY_RE = /implicitly has an 'any' type/;

/**
 * @param {string} outputPath
 * @param {string} tsconfig
 */
const runCount = (outputPath, tsconfig) => {
  const args = [
    'run',
    '-T',
    'tsc',
    '-p',
    tsconfig,
    '--noEmit',
    '--pretty',
    'false',
    '--noImplicitAny',
    'true',
  ];

  let stdout = '';
  let stderr = '';
  try {
    const result = execaSync('yarn', args, { reject: false });
    stdout = result.stdout;
    stderr = result.stderr;
  } catch (err) {
    throw new Error(`Failed to execute tsc: ${err.message}`);
  }

  const lines = `${stdout}\n${stderr}`.split(/\r?\n/);

  /** @type {Map<string, number>} */
  const byFile = new Map();
  for (const line of lines) {
    const match = line.match(DIAGNOSTIC_RE);
    if (!match) {
      continue;
    }
    const filePath = match[1];
    const message = match[5];
    if (!IMPLICIT_ANY_RE.test(message)) {
      continue;
    }

    const normalized = filePath.replaceAll('\\\\', '/');
    byFile.set(normalized, (byFile.get(normalized) || 0) + 1);
  }

  const sorted = [...byFile.entries()].sort((a, b) => {
    if (b[1] !== a[1]) {
      return b[1] - a[1];
    }
    return a[0].localeCompare(b[0]);
  });

  const rows = ['file\tcount', ...sorted.map(([file, count]) => `${file}\t${count}`)];
  fs.writeFileSync(outputPath, `${rows.join('\n')}\n`, 'utf8');

  const total = sorted.reduce((sum, [, count]) => sum + count, 0);
  console.log(
    `Wrote ${sorted.length} files with ${total} implicit any diagnostics to ${outputPath}`,
  );
};

/**
 * @param {string} filePath
 */
const toPackageName = filePath => {
  const normalized = filePath.replaceAll('\\\\', '/');
  const segments = normalized.split('/');

  if (segments[0] === 'packages' && segments[1]) {
    return `packages/${segments[1]}`;
  }
  if (segments[0] === 'services' && segments[1]) {
    return `services/${segments[1]}`;
  }
  if (segments[0] === 'golang' && segments[1]) {
    return `golang/${segments[1]}`;
  }
  return '(repo root/other)';
};

/**
 * @param {string} inputPath
 * @param {string | undefined} outputPath
 */
const runReport = (inputPath, outputPath) => {
  const raw = fs.readFileSync(inputPath, 'utf8').trim();
  const rows = raw.length === 0 ? [] : raw.split(/\r?\n/);

  if (rows.length === 0) {
    throw new Error(`Input TSV is empty: ${inputPath}`);
  }

  const header = rows.shift();
  if (header !== 'file\tcount') {
    throw new Error(`Unexpected TSV header in ${inputPath}: ${header}`);
  }

  /** @type {Map<string, number>} */
  const packageCounts = new Map();
  let repoTotal = 0;
  let repoFiles = 0;

  for (const row of rows) {
    if (!row.trim()) {
      continue;
    }
    const [file, countText] = row.split('\t');
    const count = Number.parseInt(countText, 10);
    if (!file || Number.isNaN(count)) {
      throw new Error(`Invalid TSV row: ${row}`);
    }

    repoFiles += 1;
    repoTotal += count;

    const pkg = toPackageName(file);
    packageCounts.set(pkg, (packageCounts.get(pkg) || 0) + count);
  }

  const sortedPackages = [...packageCounts.entries()].sort((a, b) => {
    if (b[1] !== a[1]) {
      return b[1] - a[1];
    }
    return a[0].localeCompare(b[0]);
  });

  const lines = [
    `repo_total\t${repoTotal}`,
    `repo_files\t${repoFiles}`,
    'package\tcount',
    ...sortedPackages.map(([pkg, count]) => `${pkg}\t${count}`),
  ];

  const report = `${lines.join('\n')}\n`;
  if (outputPath) {
    fs.writeFileSync(outputPath, report, 'utf8');
    console.log(`Wrote report to ${outputPath}`);
  } else {
    console.log(report);
  }
};

const [command, ...rest] = process.argv.slice(2);

if (!command || command === '--help' || command === '-h') {
  console.log(usage);
  process.exit(0);
}

const flags = parseFlags(rest);

if (command === 'count') {
  const outputPath = flags.output || 'implicit-any-counts.tsv';
  const tsconfig = flags.tsconfig || 'tsconfig.check.json';
  runCount(path.resolve(outputPath), tsconfig);
} else if (command === 'report') {
  const inputPath = flags.input || 'implicit-any-counts.tsv';
  runReport(path.resolve(inputPath), flags.output && path.resolve(flags.output));
} else {
  console.error(`Unknown command: ${command}`);
  console.error(usage);
  process.exit(1);
}
